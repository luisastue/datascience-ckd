<html>
<head>
<title>5.4_neural_network.ipynb</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
5.4_neural_network.ipynb</font>
</center></td></tr></table>
<pre><span class="s0">{ 
 &quot;cells&quot;: [ 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;source&quot;: [ 
    &quot;# 1. Libraries&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;source&quot;: [ 
    &quot;Hallo wie&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: 36, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# Import necessary libraries\n&quot;, 
    &quot;from sklearn.model_selection import train_test_split\n&quot;, 
    &quot;from sklearn.preprocessing import LabelEncoder\n&quot;, 
    &quot;from sklearn.metrics import accuracy_score, precision_score, f1_score, confusion_matrix\n&quot;, 
    &quot;import torch\n&quot;, 
    &quot;from torch import nn, optim\n&quot;, 
    &quot;import torch.nn.functional as F\n&quot;, 
    &quot;from torch.autograd import Variable\n&quot;, 
    &quot;import pandas as pd\n&quot;, 
    &quot;import numpy as np\n&quot;, 
    &quot;import matplotlib.pyplot as plt&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;source&quot;: [ 
    &quot;# 2. Preperation&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: 37, 
   &quot;outputs&quot;: [ 
    { 
     &quot;name&quot;: &quot;stdout&quot;, 
     &quot;output_type&quot;: &quot;stream&quot;, 
     &quot;text&quot;: [ 
      &quot;&lt;class 'pandas.core.frame.DataFrame'&gt;\n&quot;, 
      &quot;RangeIndex: 349 entries, 0 to 348\n&quot;, 
      &quot;Data columns (total 25 columns):\n&quot;, 
      &quot; #   Column  Non-Null Count  Dtype  \n&quot;, 
      &quot;---  ------  --------------  -----  \n&quot;, 
      &quot; 0   age     340 non-null    float64\n&quot;, 
      &quot; 1   bp      337 non-null    float64\n&quot;, 
      &quot; 2   sg      302 non-null    float64\n&quot;, 
      &quot; 3   al      303 non-null    float64\n&quot;, 
      &quot; 4   su      300 non-null    float64\n&quot;, 
      &quot; 5   rbc     200 non-null    object \n&quot;, 
      &quot; 6   pc      287 non-null    object \n&quot;, 
      &quot; 7   pcc     345 non-null    object \n&quot;, 
      &quot; 8   ba      345 non-null    object \n&quot;, 
      &quot; 9   bgr     306 non-null    float64\n&quot;, 
      &quot; 10  bu      331 non-null    float64\n&quot;, 
      &quot; 11  sc      332 non-null    float64\n&quot;, 
      &quot; 12  sod     263 non-null    float64\n&quot;, 
      &quot; 13  pot     262 non-null    float64\n&quot;, 
      &quot; 14  hemo    298 non-null    float64\n&quot;, 
      &quot; 15  pcv     279 non-null    float64\n&quot;, 
      &quot; 16  wbcc    243 non-null    float64\n&quot;, 
      &quot; 17  rbcc    218 non-null    float64\n&quot;, 
      &quot; 18  htn     347 non-null    object \n&quot;, 
      &quot; 19  dm      347 non-null    object \n&quot;, 
      &quot; 20  cad     347 non-null    object \n&quot;, 
      &quot; 21  appet   348 non-null    object \n&quot;, 
      &quot; 22  pe      348 non-null    object \n&quot;, 
      &quot; 23  ane     348 non-null    object \n&quot;, 
      &quot; 24  class   349 non-null    object \n&quot;, 
      &quot;dtypes: float64(14), object(11)\n&quot;, 
      &quot;memory usage: 68.3+ KB\n&quot;, 
      &quot;None\n&quot; 
     ] 
    } 
   ], 
   &quot;source&quot;: [ 
    &quot;categorical = df.select_dtypes(exclude=np.number)\n&quot;, 
    &quot;a = df.info(verbose=True)\n&quot;, 
    &quot;\n&quot;, 
    &quot;print(a)&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: 38, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;df = pd.read_csv('preprocessed/df.csv')&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: 39, 
   &quot;outputs&quot;: [ 
    { 
     &quot;name&quot;: &quot;stdout&quot;, 
     &quot;output_type&quot;: &quot;stream&quot;, 
     &quot;text&quot;: [ 
      &quot;    age    bp     sg   al   su    bgr    bu   sc    sod  pot  ...  cad_no   \n&quot;, 
      &quot;0  48.0  80.0  1.020  1.0  0.0  121.0  36.0  1.2    NaN  NaN  ...    True  \\\n&quot;, 
      &quot;1   7.0  50.0  1.020  4.0  0.0    NaN  18.0  0.8    NaN  NaN  ...    True   \n&quot;, 
      &quot;2  62.0  80.0  1.010  2.0  3.0  423.0  53.0  1.8    NaN  NaN  ...    True   \n&quot;, 
      &quot;3  48.0  70.0  1.005  4.0  0.0  117.0  56.0  3.8  111.0  2.5  ...    True   \n&quot;, 
      &quot;4  51.0  80.0  1.010  2.0  0.0  106.0  26.0  1.4    NaN  NaN  ...    True   \n&quot;, 
      &quot;\n&quot;, 
      &quot;   cad_yes  appet_good  appet_poor  pe_no  pe_yes  ane_no  ane_yes  class_ckd   \n&quot;, 
      &quot;0    False        True       False   True   False    True    False       True  \\\n&quot;, 
      &quot;1    False        True       False   True   False    True    False       True   \n&quot;, 
      &quot;2    False       False        True   True   False   False     True       True   \n&quot;, 
      &quot;3    False       False        True  False    True   False     True       True   \n&quot;, 
      &quot;4    False        True       False   True   False    True    False       True   \n&quot;, 
      &quot;\n&quot;, 
      &quot;   class_notckd  \n&quot;, 
      &quot;0         False  \n&quot;, 
      &quot;1         False  \n&quot;, 
      &quot;2         False  \n&quot;, 
      &quot;3         False  \n&quot;, 
      &quot;4         False  \n&quot;, 
      &quot;\n&quot;, 
      &quot;[5 rows x 36 columns]\n&quot; 
     ] 
    } 
   ], 
   &quot;source&quot;: [ 
    &quot;# Select object columns only\n&quot;, 
    &quot;df_categorical = df.select_dtypes(include=[object])\n&quot;, 
    &quot;\n&quot;, 
    &quot;# One-hot encode the categorical columns\n&quot;, 
    &quot;df_encoded = pd.get_dummies(df, columns=df_categorical.columns)\n&quot;, 
    &quot;# Display the first few rows of the new DataFrame\n&quot;, 
    &quot;print(df_encoded.head())&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: 40, 
   &quot;outputs&quot;: [ 
    { 
     &quot;name&quot;: &quot;stdout&quot;, 
     &quot;output_type&quot;: &quot;stream&quot;, 
     &quot;text&quot;: [ 
      &quot;&lt;class 'pandas.core.frame.DataFrame'&gt;\n&quot;, 
      &quot;RangeIndex: 349 entries, 0 to 348\n&quot;, 
      &quot;Data columns (total 36 columns):\n&quot;, 
      &quot; #   Column          Non-Null Count  Dtype  \n&quot;, 
      &quot;---  ------          --------------  -----  \n&quot;, 
      &quot; 0   age             340 non-null    float64\n&quot;, 
      &quot; 1   bp              337 non-null    float64\n&quot;, 
      &quot; 2   sg              302 non-null    float64\n&quot;, 
      &quot; 3   al              303 non-null    float64\n&quot;, 
      &quot; 4   su              300 non-null    float64\n&quot;, 
      &quot; 5   bgr             306 non-null    float64\n&quot;, 
      &quot; 6   bu              331 non-null    float64\n&quot;, 
      &quot; 7   sc              332 non-null    float64\n&quot;, 
      &quot; 8   sod             263 non-null    float64\n&quot;, 
      &quot; 9   pot             262 non-null    float64\n&quot;, 
      &quot; 10  hemo            298 non-null    float64\n&quot;, 
      &quot; 11  pcv             279 non-null    float64\n&quot;, 
      &quot; 12  wbcc            243 non-null    float64\n&quot;, 
      &quot; 13  rbcc            218 non-null    float64\n&quot;, 
      &quot; 14  rbc_abnormal    349 non-null    bool   \n&quot;, 
      &quot; 15  rbc_normal      349 non-null    bool   \n&quot;, 
      &quot; 16  pc_abnormal     349 non-null    bool   \n&quot;, 
      &quot; 17  pc_normal       349 non-null    bool   \n&quot;, 
      &quot; 18  pcc_notpresent  349 non-null    bool   \n&quot;, 
      &quot; 19  pcc_present     349 non-null    bool   \n&quot;, 
      &quot; 20  ba_notpresent   349 non-null    bool   \n&quot;, 
      &quot; 21  ba_present      349 non-null    bool   \n&quot;, 
      &quot; 22  htn_no          349 non-null    bool   \n&quot;, 
      &quot; 23  htn_yes         349 non-null    bool   \n&quot;, 
      &quot; 24  dm_no           349 non-null    bool   \n&quot;, 
      &quot; 25  dm_yes          349 non-null    bool   \n&quot;, 
      &quot; 26  cad_no          349 non-null    bool   \n&quot;, 
      &quot; 27  cad_yes         349 non-null    bool   \n&quot;, 
      &quot; 28  appet_good      349 non-null    bool   \n&quot;, 
      &quot; 29  appet_poor      349 non-null    bool   \n&quot;, 
      &quot; 30  pe_no           349 non-null    bool   \n&quot;, 
      &quot; 31  pe_yes          349 non-null    bool   \n&quot;, 
      &quot; 32  ane_no          349 non-null    bool   \n&quot;, 
      &quot; 33  ane_yes         349 non-null    bool   \n&quot;, 
      &quot; 34  class_ckd       349 non-null    bool   \n&quot;, 
      &quot; 35  class_notckd    349 non-null    bool   \n&quot;, 
      &quot;dtypes: bool(22), float64(14)\n&quot;, 
      &quot;memory usage: 45.8 KB\n&quot;, 
      &quot;None\n&quot; 
     ] 
    } 
   ], 
   &quot;source&quot;: [ 
    &quot;a = df_encoded.info(verbose=True)\n&quot;, 
    &quot;\n&quot;, 
    &quot;print(a)&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: 41, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# If 'class' has been one-hot encoded to 'class_0' and 'class_1', convert it back\n&quot;, 
    &quot;if 'class_0' in df_encoded.columns and 'class_1' in df_encoded.columns:\n&quot;, 
    &quot;    df_encoded['class'] = df_encoded['class_1']\n&quot;, 
    &quot;    df_encoded = df_encoded.drop(['class_0', 'class_1'], axis=1)\n&quot;, 
    &quot;\n&quot;, 
    &quot;# Convert all boolean columns to int\n&quot;, 
    &quot;for col in df_encoded.columns:\n&quot;, 
    &quot;    if df_encoded[col].dtype == bool:\n&quot;, 
    &quot;        df_encoded[col] = df_encoded[col].astype(int)\n&quot;, 
    &quot;\n&quot;, 
    &quot;\n&quot;, 
    &quot;# Separate features and target\n&quot;, 
    &quot;X = df_encoded.drop('class_ckd', axis=1)\n&quot;, 
    &quot;y = df_encoded['class_ckd']\n&quot;, 
    &quot;\n&quot;, 
    &quot;# Split the data into training and validation sets\n&quot;, 
    &quot;X_train, X_val, y_train, y_val = train_test_split(X, y, test_size=0.2, random_state=42)\n&quot;, 
    &quot;\n&quot;, 
    &quot;# Further split training data into training and test sets\n&quot;, 
    &quot;X_train, X_test, y_train, y_test = train_test_split(X_train, y_train, test_size=0.25, random_state=42)\n&quot;, 
    &quot;\n&quot;, 
    &quot;# Fill missing values\n&quot;, 
    &quot;X_train = X_train.fillna(X_train.median())\n&quot;, 
    &quot;X_test = X_test.fillna(X_test.median())\n&quot;, 
    &quot;X_val = X_val.fillna(X_val.median())\n&quot;, 
    &quot;\n&quot;, 
    &quot;# Convert to PyTorch tensors\n&quot;, 
    &quot;X_train = torch.tensor(X_train.values, dtype=torch.float)\n&quot;, 
    &quot;y_train = torch.tensor(y_train.values, dtype=torch.long)\n&quot;, 
    &quot;X_test = torch.tensor(X_test.values, dtype=torch.float)\n&quot;, 
    &quot;y_test = torch.tensor(y_test.values, dtype=torch.long)\n&quot;, 
    &quot;X_val = torch.tensor(X_val.values, dtype=torch.float)\n&quot;, 
    &quot;y_val = torch.tensor(y_val.values, dtype=torch.long)&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;source&quot;: [ 
    &quot;# 3. Model Creation&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: 42, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;class Net(nn.Module):\n&quot;, 
    &quot;    def __init__(self):\n&quot;, 
    &quot;        super(Net, self).__init__()\n&quot;, 
    &quot;        self.fc1 = nn.Linear(X_train.shape[1], 50)\n&quot;, 
    &quot;        self.fc2 = nn.Linear(50, 2)  # Assuming binary classification\n&quot;, 
    &quot;\n&quot;, 
    &quot;    def forward(self, x):\n&quot;, 
    &quot;        x = F.relu(self.fc1(x))\n&quot;, 
    &quot;        x = self.fc2(x)\n&quot;, 
    &quot;        return x&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;source&quot;: [ 
    &quot;# 4. Training&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: 44, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;net = Net()\n&quot;, 
    &quot;\n&quot;, 
    &quot;criterion = nn.CrossEntropyLoss()\n&quot;, 
    &quot;optimizer = optim.SGD(net.parameters(), lr=0.01)\n&quot;, 
    &quot;\n&quot;, 
    &quot;train_loss = []\n&quot;, 
    &quot;val_loss = []\n&quot;, 
    &quot;\n&quot;, 
    &quot;for epoch in range(500):  # Loop over the dataset multiple times\n&quot;, 
    &quot;    optimizer.zero_grad()  # Zero the parameter gradients\n&quot;, 
    &quot;    outputs = net(X_train)  # Forward pass\n&quot;, 
    &quot;    loss = criterion(outputs, y_train)  # Compute loss\n&quot;, 
    &quot;    loss.backward()  # Backward pass\n&quot;, 
    &quot;    optimizer.step()  # Optimize\n&quot;, 
    &quot;    train_loss.append(loss.item())  # Record the loss\n&quot;, 
    &quot;\n&quot;, 
    &quot;    # Calculate validation loss\n&quot;, 
    &quot;    val_outputs = net(X_val)  # Forward pass on validation data\n&quot;, 
    &quot;    val_loss_epoch = criterion(val_outputs, y_val)  # Compute validation loss\n&quot;, 
    &quot;    val_loss.append(val_loss_epoch.item())  # Record the validation loss\n&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;source&quot;: [ 
    &quot;# 5. Evaluation&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: 45, 
   &quot;outputs&quot;: [ 
    { 
     &quot;name&quot;: &quot;stdout&quot;, 
     &quot;output_type&quot;: &quot;stream&quot;, 
     &quot;text&quot;: [ 
      &quot;Accuracy: 0.6714285714285714, Precision: 0.6714285714285714, F1: 0.8034188034188035\n&quot;, 
      &quot;Confusion matrix: \n&quot;, 
      &quot;[[ 0 23]\n&quot;, 
      &quot; [ 0 47]]\n&quot; 
     ] 
    } 
   ], 
   &quot;source&quot;: [ 
    &quot;# Get predictions\n&quot;, 
    &quot;outputs = net(X_test)\n&quot;, 
    &quot;_, predicted = torch.max(outputs, 1)\n&quot;, 
    &quot;\n&quot;, 
    &quot;# Calculate metrics\n&quot;, 
    &quot;accuracy = accuracy_score(y_test, predicted)\n&quot;, 
    &quot;precision = precision_score(y_test, predicted)\n&quot;, 
    &quot;f1 = f1_score(y_test, predicted)\n&quot;, 
    &quot;print(f\&quot;Accuracy: {accuracy}, Precision: {precision}, F1: {f1}\&quot;)\n&quot;, 
    &quot;\n&quot;, 
    &quot;# Confusion matrix\n&quot;, 
    &quot;conf_mat = confusion_matrix(y_test, predicted)\n&quot;, 
    &quot;print(f\&quot;Confusion matrix: \\n{conf_mat}\&quot;)&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;source&quot;: [ 
    &quot;# 6. Visualizing the performance&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: 34, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;train_loss = []\n&quot;, 
    &quot;for epoch in range(500):  # Loop over the dataset multiple times\n&quot;, 
    &quot;    optimizer.zero_grad()  # Zero the parameter gradients\n&quot;, 
    &quot;    outputs = net(X_train)  # Forward pass\n&quot;, 
    &quot;    loss = criterion(outputs, y_train)  # Compute loss\n&quot;, 
    &quot;    loss.backward()  # Backward pass\n&quot;, 
    &quot;    optimizer.step()  # Optimize\n&quot;, 
    &quot;    train_loss.append(loss.item())  # Record the loss\n&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: 35, 
   &quot;outputs&quot;: [ 
    { 
     &quot;ename&quot;: &quot;NameError&quot;, 
     &quot;evalue&quot;: &quot;name 'X_val' is not defined&quot;, 
     &quot;output_type&quot;: &quot;error&quot;, 
     &quot;traceback&quot;: [ 
      &quot;\u001B[0;31m---------------------------------------------------------------------------\u001B[0m&quot;, 
      &quot;\u001B[0;31mNameError\u001B[0m                                 Traceback (most recent call last)&quot;, 
      &quot;Cell \u001B[0;32mIn[35], line 11\u001B[0m\n\u001B[1;32m      8\u001B[0m train_loss\u001B[38;5;241m.\u001B[39mappend(loss\u001B[38;5;241m.\u001B[39mitem())  \u001B[38;5;66;03m# Record the training loss\u001B[39;00m\n\u001B[1;32m     10\u001B[0m \u001B[38;5;66;03m# Calculate validation loss\u001B[39;00m\n\u001B[0;32m---&gt; 11\u001B[0m val_outputs \u001B[38;5;241m=\u001B[39m net(\u001B[43mX_val\u001B[49m)  \u001B[38;5;66;03m# Forward pass on validation data\u001B[39;00m\n\u001B[1;32m     12\u001B[0m val_loss_epoch \u001B[38;5;241m=\u001B[39m criterion(val_outputs, y_val)  \u001B[38;5;66;03m# Compute validation loss\u001B[39;00m\n\u001B[1;32m     13\u001B[0m val_loss\u001B[38;5;241m.\u001B[39mappend(val_loss_epoch\u001B[38;5;241m.\u001B[39mitem())  \u001B[38;5;66;03m# Record the validation loss\u001B[39;00m\n&quot;, 
      &quot;\u001B[0;31mNameError\u001B[0m: name 'X_val' is not defined&quot; 
     ] 
    } 
   ], 
   &quot;source&quot;: [ 
    &quot;val_loss = []\n&quot;, 
    &quot;for epoch in range(500):  # Loop over the dataset multiple times\n&quot;, 
    &quot;    optimizer.zero_grad()  # Zero the parameter gradients\n&quot;, 
    &quot;    outputs = net(X_train)  # Forward pass\n&quot;, 
    &quot;    loss = criterion(outputs, y_train)  # Compute loss\n&quot;, 
    &quot;    loss.backward()  # Backward pass\n&quot;, 
    &quot;    optimizer.step()  # Optimize\n&quot;, 
    &quot;    train_loss.append(loss.item())  # Record the training loss\n&quot;, 
    &quot;\n&quot;, 
    &quot;    # Calculate validation loss\n&quot;, 
    &quot;    val_outputs = net(X_val)  # Forward pass on validation data\n&quot;, 
    &quot;    val_loss_epoch = criterion(val_outputs, y_val)  # Compute validation loss\n&quot;, 
    &quot;    val_loss.append(val_loss_epoch.item())  # Record the validation loss\n&quot;, 
    &quot;\n&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: 47, 
   &quot;outputs&quot;: [ 
    { 
     &quot;data&quot;: { 
      &quot;text/plain&quot;: &quot;&lt;Figure size 1000x500 with 1 Axes&gt;&quot;, 
      &quot;image/png&quot;: &quot;iVBORw0KGgoAAAANSUhEUgAAA0sAAAHUCAYAAADr67PJAAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjcuMSwgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy/bCgiHAAAACXBIWXMAAA9hAAAPYQGoP6dpAABSBUlEQVR4nO3de3zO9f/H8ee1s/NhY2lyiGINMxOqySGECEOJHCpRThWFqRwSFTqInFtRfuXrkCLxJeXbWZZD0tgQSmlzrs1muz6/P+a6uLZh12zX5zMe99vNt12f63Ndn9cur+/as/fhYzMMwxAAAAAAwIWX2QUAAAAAgBURlgAAAAAgF4QlAAAAAMgFYQkAAAAAckFYAgAAAIBcEJYAAAAAIBeEJQAAAADIBWEJAAAAAHJBWAIAwEK4VzwAWAdhCQAK2OjRo1WrVq1L/undu/cVXWPGjBmqVatWob/GqkaPHq2WLVvm+tyZM2cUGRmpAQMGXPT1ycnJCgsL0/Tp0y97rd9//121atXSihUrJEkrVqxQrVq19Pvvv+f5NXm1dOlSvfLKK87HeblWQfHktQCgqPAxuwAAuNoMGjRIPXr0cD6eNWuWdu3apZkzZzqPlSxZ8oqu0b17dzVt2rTQX1MUBQQE6J577tHy5ct17NgxlS9fPsc5q1atUmZmprp27er2+zdv3lxLlixRxYoVC6JcF7Nnz1ajRo08ci0AwOURlgCggFWpUkVVqlRxPi5fvrz8/PxUv379ArvGddddp+uuu67QX1NUdevWTUuWLNFnn32mXr165Xj+o48+0m233abKlSu7/d7ly5fPNYAVBk9eCwCQE9PwAMAkK1as0C233KKlS5fqjjvuUKNGjZSYmKjMzEzNmzdPHTp0UL169VS/fn316NFD33//vfO12afU9e7dW88++6zmzZun5s2bq27duurRo4d27NhxRa+RpC+//FLR0dGqV6+e7r77bq1evVqtW7fWjBkzLvn9LV26VNHR0apfv77q1aunTp066bPPPsvx/W/fvl3333+/6tatqxYtWujtt992eZ+TJ08qJiZGjRo10q233qqpU6fKbrdf8tr16tXTTTfdpFWrVuV47tdff9Xu3bvVrVs3SVJ8fLyGDBmiJk2aKCwsTE2bNtWLL76oM2fO5PreuU1X++9//6t7771X9erVU5cuXRQfH5/jdZe7TsuWLfXHH3/oo48+cr5/btf65ptv1LNnT0VGRqpx48YaMWKE/vzzT7c/1/z6+++/FRMTo2bNmqlevXrq1q2bPv/8c5dzvvnmG913332KiIjQrbfeqscff1x79+51Pn/w4EE99thjaty4scLDw3X//fdr06ZNBVIfABQkwhIAmCgzM1OxsbGaNGmSYmJiVKNGDU2bNk2zZs3S/fffrwULFmjixIk6ceKEnnjiCaWmpl70vdatW6fPP/9czz33nF577TUlJydr6NChyszMzPdrvv/+ew0aNEiVKlXSjBkz1KtXL40bN87ll/PcLF68WGPHjlWrVq00d+5cTZs2TX5+fnr66af1119/Oc+z2+168skn1b59e82bN08NGjTQlClT9NVXXzmf79+/vzZt2qRRo0bp5Zdf1k8//aQ1a9Zc9rPt2rWrtm7dqkOHDrkcX7lypcqWLavWrVvr77//Vq9evZSamqqXX35Z8+fP1z333KP33ntPixYtuuw1JGnjxo0aNmyYatWqpbfeekvt2rXTM88843JOXq4zc+ZMVahQQc2aNbvo1LuVK1fq4YcfVqVKlfTaa68pJiZGW7du1f3336+jR4/m+XPNr+TkZHXr1k1btmzRU089pRkzZigkJESDBw/WJ598Ikk6dOiQBg0apDp16mj27NmaNGmS9u/frwEDBshut8tut2vgwIFKTU3VlClTNGvWLJUtW1aPP/64Dhw4cEX1AUBBu2an4aWnpys6OlrPP/+8GjdunKfXbN68WZMmTdJvv/2mWrVq6YUXXlDt2rULuVIAV7vHHntMzZs3dz7++++/9dRTT7lsAuHv76+hQ4dq9+7dF53Ol5GRobffftu5Hurff//VqFGj9Ouvv6pOnTr5es2MGTN00003aebMmbLZbJKkwMBADR8+/JLf06FDh/TII49o0KBBzmMhISGKjo5WXFyc7rnnHklZO78NGjRI3bt3lyRFRkZq/fr1+vLLL9W0aVP973//044dOzR//nzdeeedkqTbbrvtops7XKhTp0569dVXtWrVKmcdGRkZWrVqlTp27Cg/Pz/t2bNHoaGhmj59uvMzuP322/XNN9/ohx9+uOQmEQ5vvfWW6tWrp6lTp0qSc13Yq6++6jwnL9e55ZZb5Ofnp/Lly+f6d2y32zVt2jRFRUW5vHeDBg3Uvn17vf322xo5cmSePtf8euedd3Ts2DGtW7dOISEhkqRmzZqpX79+mjJlijp06KAdO3bozJkzGjhwoIKDgyVlTQH9/PPPlZKSotTUVO3bt0+DBg1Ss2bNJGWNBM6cOVPp6en5rg0ACsM1GZbS0tI0YsQIJSQk5Pk1hw4d0qOPPqpHH31UHTp00Ntvv61BgwZp7dq18vPzK8RqAVztQkNDXR47fhE+duyY9u3bpwMHDuiLL76QpEv+MlmzZk2XjSMcv6heajTqUq9JT0/X1q1bNXjwYGdQkqS2bds6fym/mNGjR0uSTp065fwefvjhh1y/h4iICOfXjrCQkpIiSdqyZYt8fX1dfsEvXry4mjVrph9//PGSNZQvX14tWrRwCUtfffWVjh496pyCFxUVpaioKJ09e1aJiYk6cOCA9uzZo2PHjqls2bKXfH8pa+e9X375RU888YTL8Xbt2rkEmiu9jiTt379fSUlJGjFihMvxKlWqKCIiQps3b3Y5fqnPNb82b96siIgIZ1ByuPfeexUTE6N9+/YpPDxc/v7+6tatm9q2bas777xTjRs3Vr169SRJJUqUUM2aNfX888/r66+/VlRUlO68807FxMRcUW0AUBiuubCUmJioESNGuH0fi/fff1/16tXTkCFDJEljxoxRx44dtW/fPkaXAFyR4sWLuzz++eefNWHCBP38888qVqyYatasqeuvv17Spe/BU6xYMZfHXl5ZM60vtb7nUq85ceKEMjMzFRgY6HKOt7f3ZX/BP3jwoMaOHavvvvtOvr6+uvHGG50/K7N/DwEBATlqcJxz8uRJlS1b1iWsSVKFChUueX2Hrl27auDAgfrll18UFhamlStXqm7dus5a7Ha7XnvtNS1evFgpKSmqVKmS6tWrJ39//zy9/8mTJ2UYhsqVK+dyPPsUuiu9jiSdOHFCkhQUFJTjuaCgIO3atcvl2KU+1/w6efKkbrjhhlyvL2WF45o1a+r999/XvHnztGzZMi1atEilS5dWz5499eSTT8pmsyk2NlazZ8/W+vXrtXLlSvn6+qpVq1aaMGGCypQpc0U1AkBBuubC0ubNm9W4cWM99dRTOaY5bNmyRZMnT1ZiYqKqVq2qIUOG6O6773a+Ljo62nlusWLFtGHDBk+WDuAa8M8//6h///6qVauWPv30U914443y8vLSpk2btG7dOo/WEhgYKF9fXyUnJ7scdwSpi7Hb7RowYIB8fX21bNkyhYaGysfHR4mJifr444/dqqFcuXI6fvy4MjMz5e3t7Tx+qetfqGnTpqpYsaJWr16tG264QRs3btSzzz7rfH7evHl69913NWHCBLVp00alSpWSJOfI0+WULVtWXl5eOT6j7PVd6XUc15KU41qSlJSUlCOwFYYyZcooKSkp1+tLctZw4bS6uLg4LVmyRHPmzFHt2rXVrl07BQcHa/z48Ro3bpzi4+O1du1azZ8/X+XKldO4ceMK/fsAgLy65jZ46Nmzp8aMGZPjv6YmJSVp4MCBio6O1qpVq9S/f3+NHj1aW7ZskZQ1DS8gIEDDhg3T7bffrj59+igxMdGMbwHAVWzfvn06ceKE+vTpo5o1azpHev73v/9JuvQoUUHz9vZWgwYNcux0tnHjRmVkZFz0dcePH9f+/fvVrVs31a1bVz4+Wf9dLj/fw2233aaMjAyX/ziVnp6ub775Js/fQ5cuXbRu3Tpt3LhR3t7e6tChg/P5uLg41axZU127dnUGmCNHjmjPnj15qtPf318RERH673//6zJqs3HjRpfz8nodx993bqpXr64KFSpo9erVLscPHTqkbdu2qUGDBpet90rdeuut2rp1q/744w+X45988okqVKigqlWr6t1331WLFi2Unp4uPz8/3XbbbZo4caIk6fDhw9q6datuv/127dixQzabTaGhoXrqqad088036/Dhw4X+PQCAO665kaWLWbx4sW6//XY9+OCDkqSqVavq119/1cKFC9WwYUOlpKRo2rRpGjJkiAYOHKhFixapX79+WrdunUqUKGFy9QCuFtWrV1fJkiU1Z84c+fj4yMfHR+vWrdOyZcskXXr9UWEYNmyYevfurWHDhqlbt246fPiwpk+fLkk5psY5BAYGKiQkRIsXL9Z1112n0qVL66uvvnLu+ubO93DbbbcpKipKzz33nI4ePaqQkBAtWrRIx44dyzE98GKio6M1d+5czZ49W23btnVZo1WvXj3NmjVL8+bNU/369XXgwAHNnTtX6enpea5z+PDh6tu3r4YMGaL7779f+/fv15w5c1zOyet1SpcurV27dmnz5s3ONT4OXl5eGj58uGJiYjRixAjde++9On78uGbOnKkyZcrooYceylO9l7N8+fIcU+G8vLzUp08fPfTQQ/rkk0/Ur18/DRkyRGXLltXKlSv1/fffa/LkyfLy8lKTJk00bdo0DR48WA8++KC8vb314Ycfys/PTy1atFBISIgCAgI0cuRIDR06VEFBQfr222/166+/qk+fPgXyPQBAQSEsnbNv3z598cUXLgtiz549q+rVq0vK+q+TLVu2dO5ONXHiRDVv3lwbN25Ux44dTakZwNWnVKlSmjVrlqZMmaInnnhCJUqUUGhoqN5//309+uij2rJlS552gisoDRs21IwZMzR9+nQNGjRIISEhev755/XUU09d8j8UzZo1S5MmTdLo0aPl5+enmjVravbs2Zo8ebK2bNnistPf5cycOVPTpk3Tm2++qbS0NLVv31733XdfjhGvi6lWrZpuvfVW/fjjj5o0aZLLcwMHDtTx48e1aNEivfXWW6pUqZI6deokm82muXPn6tSpU5d9/4YNG2r+/Pl67bXXNGTIEFWuXFmTJ0/WY4895tZ1SpcurYcffliTJ0/WI488onfeeSfHtaKjo1WiRAnNnTtXgwcPVsmSJdW0aVMNHz48z+u4LmfWrFk5jnl7e6tPnz6qUKGCPvjgA7366qt68cUXdfbsWdWuXVuzZs3SXXfdJUmqXbu25syZo7feekvDhw9XZmam6tSpo9jYWN14442SpNjYWL366quaNGmSTp06pWrVqumFF15wme4OAFZgM650tWcRVqtWLS1atEiNGzfWoEGDVKZMGZd/uUmSj4+PQkJC1LJlS/Xo0cNlG9nu3burdevWedpaFgCKos8//1zXXXedwsLCnMcSEhLUoUMHl1+QAQC4GjGydE716tW1detWVa1a1XksNjZW6enpeuyxx1S/fn3t3r3b+Vx6eroOHTqkypUrm1EuAHjE119/rTVr1ujpp59W9erVdeTIEc2ePVs33nijoqKizC4PAIBCRVg6p2fPnnrvvff0+uuvq0uXLvr555/12muvafLkyZKkvn37qlevXoqMjNTtt9+uBQsWyN/f3+VGkgBwtRk1apQCAgI0e/Zs/f333ypbtqyaNm2qESNGuLXtNQAARRHT8M5Nw5Okb7/9VtOmTdOePXsUHByshx56yLnhgyRt2LBB06ZN0x9//KE6derohRde0E033WRW+QAAAAAK0TUdlgAAAADgYq65+ywBAAAAQF4QlgAAAAAgF4QlAAAAAMgFYQkAAAAAcnHNbR1+9Ohpmb2lhc0mBQaWskQtKBroGbiLnoG7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Tp48qaefjlHVqtUUHd1dd97Zwvl8sWLFNXr082rWrKUqVbpeLVq00k031dL+/fvk6+urkiVLysvLS4GBQfL29nZ572XLPlS3bj3Url0HValSTY8/PlQ33lhTy5f/x3lOu3YddeedzVWlSlX16NFLv/66qwA/rdwxsmQW1iwBAAAUXTZb1giPhafh+fn5qWnT5tq0aaMaNWqiTZs2qnnzu1ShQkW1a9dBS5YsVkLCHv32234lJu5xjhBdzG+/7VPlyjeoWLFizmOhobfo22+/liTVrh0qf39/vf32XO3fv1d79ybq998PqVGjJpet9bffftNDDz3qcqxOnbo6cGC/83Hlyjc4vy5evIQyMjLy9DlcCUaWTMKaJQAAgCLOZpN8i3v2j5ujWXfd1UZffbVJ6enp+vrr/+muu1orKelv9e17v376aYtq1QrVsGHD1aPHg3l8R9ffXi/cze6HH77TI4/01tGjyWrS5Ha9+OKUywYwBz8/vxzHMjPtysy0Ox/7+np+5zxGlkziXLNkch0AAAC4ejVs2Eh2e6aWLFmsgIAAhYdHaMWK/6hUqTKaMuUN53nLli257HtVr15Dhw4d1D///KOSJUtKkhISdjufX7XqI91zz70aMWKUJCkjI0N//PG7IiNvlSTZLhH0qlSpql9+2ammTZs7j/3yy88KD49w59stcIwsmeT8PWmJSwAAACgcPj4+ataspRYtekctWtwlm82m0qXL6MiRv7Rly2b98cfvev/9d7Vp00alp6df8r1uvbWxgoOv08svv6DfftuvNWtW6fPP1zufL126jHbu3K69exO1b99eTZ48QUePJjvfNyAgQKdPn9LBgwdzTKG7//5eWr58idau/VQHDx7Q7NkztHdvgjp27Fzgn4k7CEsmISMBAADAE+66q41SU1N01113S5Jatmytu+9up+eeG6X+/fvop5+2aMiQJ3XgwP5LBiYfHx9NmfKGTp8+rYcfflAffbRM0dHdnc8//PBAlStXXgMH9tNTTw2Wn5+fOnfu5hx9ioy8VSEhN+jBB+9TYuKebDW21oABg7VgwRz16/eAtm6N02uvzVTVqtUK/gNxg824xoY2kpNPmx5UbDapS+yPOnQsVU82u1G9GlY2tyBYns0mBQWVskT/omigZ+Auegb5cS31zdmz6Tp69E8FBlaSr2/O9TXIOx8fL2Vk2C9/4hW61N+Zo3cvh5Elkzh+oFzlP1cAAACAIouwZBJnWLra/zMMAAAAUEQRlgAAAAAgF4Qlkzi3DmdgCQAAALAkwpJJuCktAABA0cMSiqKjIP6uCEsmYc0SAABA0eHllfVrc2ZmxmXOhFWkp6dJkry9ffL9Hvl/Ja6IcW5MiagEAABgfV5e3vL1DdA//5yQt7e3bDbGHPLLbrcpM7Pwfgs2DEPp6Wn655/jKlaspDPo5gdhySTnR5bMrQMAAACXZ7PZVKZMeR09+peOHTtidjlFmpeXl+z2wr/PUrFiJVW6dPkreg/CkknOr1kiLQEAABQFPj6+qlixsjIyzppdSpFls0nlypXQ8eP/Fuqggbe3zxWNKDkQlkzCyBIAAEDRY7PZ5OvrZ3YZRZbNJgUEBMjX92yR+D2YyZYmcW4dbnIdAAAAAHJHWDKJkeMLAAAAAFZCWDLJ+ZEl0hIAAABgRYQlkzg3eCArAQAAAJZEWDKJc4MHc8sAAAAAcBGEJZOwwQMAAABgbZYIS+np6erQoYN++OGHi56za9cude/eXeHh4eratat27tzpwQoL3vkNHohLAAAAgBWZHpbS0tI0fPhwJSQkXPSclJQUDRgwQA0bNtSKFSsUERGhgQMHKiUlxYOVFjCm4QEAAACWZmpYSkxM1H333aeDBw9e8rw1a9bI399fI0eOVI0aNfTss8+qRIkSWrt2rYcqLXhs8AAAAABYm6lhafPmzWrcuLGWLFlyyfO2b9+uyMhI2Ww2SVl3Tm7QoIG2bdvmgSoLB2uWAAAAAGvzMfPiPXv2zNN5SUlJqlmzpsuxwMDAS07du5hzectUNptrSLJCTbA2R4/QK8gregbuomeQH/QN3GWVnsnr9U0NS3mVmpoqPz8/l2N+fn5KT093+70CA0sVVFlXxDH9LqCYr4KCrFETrM8q/Yuig56Bu+gZ5Ad9A3cVlZ4pEmHJ398/RzBKT09XQECA2+919Ohp09cJZY0sZRWRkpKu5OTT5hYEy7PZsn6oWKF/UTTQM3AXPYP8oG/gLqv0jKOOyykSYSk4OFjJyckux5KTk1WxYkW338swrLGpgvOmtBapB0UD/QJ30TNwFz2D/KBv4K6i0jOmbx2eF+Hh4dq6dev5TREMQz/99JPCw8NNriz/2A0PAAAAsDbLhqWkpCSdOXNGktS2bVudOnVKkyZNUmJioiZNmqTU1FS1a9fO5CqvgPM+S6QlAAAAwIosG5aioqK0Zs0aSVLJkiU1d+5cxcXFKTo6Wtu3b9e8efNUvHhxk6vMP0ISAAAAYG2WWbO0e/fuSz6uV6+ePvroI0+WVKguXLMEAAAAwHosO7J0tTOy/RMAAACAtRCWTHLhZhUAAAAArIewZBIiEgAAAGBthCWTsGYJAAAAsDbCksnISgAAAIA1EZZMcOE6JdYsAQAAANZEWDKBcZGvAQAAAFgHYckEDCYBAAAA1kdYMsGFWclOcgIAAAAsibBkBpc1SybWAQAAAOCiCEsmYM0SAAAAYH2EJRMYpCUAAADA8ghLJnDNSqQlAAAAwIoIS55m2FX28yf0qPfqrIdkJQAAAMCSCEse5n1iv0okfKSBPufCksn1AAAAAMgdYcnjsuKRjzIveAQAAADAaghLHmc797/nYhLz8AAAAABLIix5ms0RlrIQlQAAAABrIix5mJEtJjGwBAAAAFgTYcnTzo0seTnCkpm1AAAAALgowpLHua5ZMhhaAgAAACyJsORptqyP3HaZ0wAAAACYi7DkcY5peHZJrFkCAAAArIqw5GnshgcAAAAUCYQlj2M3PAAAAKAoICx5mi3bTWkZWwIAAAAsibDkaWwdDgAAABQJhCWPy751uJm1AAAAALgYwpKHGdm2DicrAQAAANZEWPK4c9PwbNyUFgAAALAywpKn2S68HS1BCQAAALAqwpLH2S74ymDNEgAAAGBRhCVPu2BkyUsGY0sAAACARRGWPC77yBJxCQAAALAiwpKn2S4MS6xaAgAAAKyKsORptvMfuY2oBAAAAFgWYcnj2OABAAAAKAoISx5mZAtLdtISAAAAYEmEJU/LNg2PqAQAAABYE2HJ0y64J62XDHZ4AAAAACyKsORx2dYskZYAAAAASyIseVr2rcPJSgAAAIAlEZY8jjVLAAAAQFFAWPI0W/ZpeAAAAACsiLDkca5hiXl4AAAAgDURljyNrcMBAACAIoGw5GkXTMPzksHAEgAAAGBRhCUT2cRtlgAAAACrMjUspaWlacyYMWrYsKGioqIUGxt70XPXr1+vdu3aKSIiQg888IB++eUXD1ZasIxz65ZYswQAAABYl6lhacqUKdq5c6cWLlyocePGaebMmVq7dm2O8xISEjRixAgNHDhQH3/8sUJDQzVw4EClpqaaUHUBOLduiTVLAAAAgHWZFpZSUlK0dOlSPfvsswoLC1Pr1q3Vv39/LV68OMe533zzjWrWrKnOnTurSpUqGj58uJKSkpSYmGhC5VfuwpElBpYAAAAAazItLMXHxysjI0MRERHOY5GRkdq+fbvsdrvLuWXLllViYqLi4uJkt9u1YsUKlSxZUlWqVPF02QXkgrBkciUAAAAAcudj1oWTkpJUrlw5+fn5OY8FBQUpLS1NJ06cUPny5Z3H27dvr40bN6pnz57y9vaWl5eX5s6dqzJlyrh93Qs2ozOPzSYZ5++4ZImaYGmOHqFXkFf0DNxFzyA/6Bu4yyo9k9frmxaWUlNTXYKSJOfj9PR0l+PHjx9XUlKSxo4dq/DwcH3wwQeKiYnRRx99pMDAQLeuGxhY6soKLwD2c387XrLL28dLQUHm14SiwQr9i6KFnoG76BnkB30DdxWVnjEtLPn7++cIRY7HAQEBLsenTZumm2++Wb169ZIkTZw4Ue3atdPy5cs1YMAAt6579Ohp09cJlXNMw7NJZ89mKjn5tLkFwfJstqwfKlboXxQN9AzcRc8gP+gbuMsqPeOo43JMC0vBwcE6fvy4MjIy5OOTVUZSUpICAgJUunRpl3N/+eUX9e7d2/nYy8tLtWvX1uHDh92+rmGJ3bodS8UMi9SDooJ+gbvoGbiLnkF+0DdwV1HpGdM2eAgNDZWPj4+2bdvmPBYXF6e6devKy8u1rIoVK2rv3r0ux/bv36/KlSt7otQCZ5ybI+nFBg8AAACAZZkWlooVK6bOnTtr/Pjx2rFjhzZs2KDY2Fj16dNHUtYo05kzZyRJ9913n/7zn/9o5cqVOnDggKZNm6bDhw+rS5cuZpV/hS7cOpy4BAAAAFiRadPwJCkmJkbjx49X3759VbJkSQ0dOlRt2rSRJEVFRemll15SdHS02rdvr3///Vdz587VX3/9pdDQUC1cuNDtzR2s43xYAgAAAGBNNuMaG9pITjZ/AWLZebfI9+wptUh7Vf4VbtJ7vRuYWxAsz2aTgoJKWaJ/UTTQM3AXPYP8oG/gLqv0jKOOyzFtGh6ytg7n5woAAABgTYQlExg6fxesa2xgDwAAACgyCEtmsGV97DZ2wwMAAAAsi7BkiqyRJS+iEgAAAGBZhCUTOO6zZDt3U1oAAAAA1kNYMoXN+b9MxAMAAACsibBkAuPcx+4lu+xkJQAAAMCSCEtmsJ0fWWJgCQAAALAmwpKpDKbhAQAAABZFWDKBYxoeGzwAAAAA1kVYMoFhO791OFkJAAAAsCbCkikca5aISgAAAIBVEZZMYFywwYPBPDwAAADAkghLpnBMw7MztgQAAABYFGHJFDbnVwwsAQAAANZEWDKBccGaJbISAAAAYE2EJRNcuBseQ0sAAACANRGWTMHIEgAAAGB1hCUTnJ+Gx8ASAAAAYFWEJTM4tg63MbIEAAAAWBVhyQQuGzwwtAQAAABYEmHJFOfDEgAAAABrIiyZgK3DAQAAAOsjLJngwq3DmYUHAAAAWBNhyRSMLAEAAABWR1gygevW4cQlAAAAwIoIS6ZggwcAAADA6ghLJnCsWbKxZgkAAACwLMKSKVizBAAAAFgdYckE3JQWAAAAsD7CkgkcYcmLcSUAAADAsghLZrAxDQ8AAACwOsKSCVy3Dje3FgAAAAC5IyyZwGXNEmNLAAAAgCURlkzB1uEAAACA1RGWTGAQlgAAAADLIyyZ4PxNacU0PAAAAMCiCEumcGwdbmdkCQAAALAowpIJXHbDM7cUAAAAABdBWDKBIywRlQAAAADrIiyZwLFmyUuGDObhAQAAAJZEWDLFhfdZAgAAAGBFhCUTOAISW4cDAAAA1kVYMoFx7mNngwcAAADAughLJnBs8OBls4uhJQAAAMCaCEsmIyoBAAAA1pTvsLR3716dPn1akvTVV19pwoQJWrp0aYEVdjUzbI5peKxZAgAAAKwqX2FpyZIluvfee/Xrr79q165devzxx3Xo0CFNnz5d06dPL+garzrOaXjshgcAAABYVr7C0oIFC/TKK6+oUaNGWr58uUJDQ7VgwQK9/vrrbo0upaWlacyYMWrYsKGioqIUGxt70XN3796tBx54QPXq1VPHjh31/fff56d0S7hwNzwAAAAA1pSvsHTkyBFFRkZKkr744gu1atVKknTdddfp33//zfP7TJkyRTt37tTChQs1btw4zZw5U2vXrs1x3unTp/Xwww+rZs2aWrVqlVq3bq0hQ4bo6NGj+SnfdIbzPkvnHjMXDwAAALAcn/y86MYbb9SqVatUvnx5HT58WK1atdLZs2cVGxur2rVr5+k9UlJStHTpUs2fP19hYWEKCwtTQkKCFi9erLZt27qc+9FHH6l48eIaP368vL29NWzYMG3atEk7d+5Us2bN8vMtmMwxDc8uKWukyXaJswEAAAB4Xr7C0qhRo/Tkk0/q5MmT6tmzp2rUqKEXXnhB69ev15w5c/L0HvHx8crIyFBERITzWGRkpObMmSO73S4vr/ODXps3b9Zdd90lb29v57Hly5fnp3RLMLJFI4O0BAAAAFhOvsLSbbfdpu+++06nT59WmTJlJEmDBg1STEyMfH198/QeSUlJKleunPz8/JzHgoKClJaWphMnTqh8+fLO44cOHVK9evX0/PPPa+PGjQoJCdGoUaOcUwHdYbNAKDk/De/c9DubNeqCdTn6gz5BXtEzcBc9g/ygb+Auq/RMXq+fr7AkSV9//bXCwsIkScuWLdN///tf3XLLLRo0aJBLALqY1NTUHOc5Hqenp7scT0lJ0bx589SnTx/Nnz9fn376qR555BF99tlnqlSpklt1BwaWcuv8wnDKJ+tjd4SlwMCS8vXmlle4PCv0L4oWegbuomeQH/QN3FVUeiZfYemtt97SggUL9O6772rv3r0aO3asunfvrvXr1+vkyZMaN27cZd/D398/RyhyPA4ICHA57u3trdDQUA0bNkySdMstt+ibb77Rxx9/rMcee8yt2o8ePW36vY3OZmatVfI6F5aSk08TlnBJNlvWDxUr9C+KBnoG7qJnkB/0DdxllZ5x1HE5+QpL//nPfzRjxgyFh4fr2Wef1a233qoJEybo559/Vv/+/fMUloKDg3X8+HFlZGTI59xIS1JSkgICAlS6dGmXcytUqKAbb7zR5Vi1atX0559/ul27YcgC/2d2nYZnt0sGWQl5YI3+RVFCz8Bd9Azyg76Bu4pKz+TrV/STJ0/qxhtvlGEY+vLLL9WiRQtJUsmSJZWZmZmn9wgNDZWPj4+2bdvmPBYXF6e6deu6bO4gSfXr19fu3btdju3bt08hISH5Kd905++z5PoYAAAAgHXkKyzVrl1bb7/9tmbOnKljx46pdevWOnLkiF577TXVr18/T+9RrFgxde7cWePHj9eOHTu0YcMGxcbGqk+fPpKyRpnOnDkjSerRo4d2796tGTNm6MCBA5o+fboOHTqkTp065ad80xnnPnabY+vwohCrAQAAgGtMvsLS+PHjtWXLFi1cuFDDhw9XSEiIFixYoD/++CNPU/AcYmJiFBYWpr59+2rChAkaOnSo2rRpI0mKiorSmjVrJMn5/l988YU6dOigL774QvPmzVNwcHB+yjdd9pvSAgAAALAem1FAwxrp6el52gXPbMnJ5i9A/PvD/go7ulaTzvbU/MwO+t+wO1TM1/vyL8Q1y2aTgoJKWaJ/UTTQM3AXPYP8oG/gLqv0jKOOy8n31uG7du3S22+/rX379ikzM1PVq1dXr1691KhRo/y+5TXDMQ3PsRseP1wAAAAA68nXNLz169frvvvuk2EYio6OVnR0tGw2mx5++GFt2LChoGu86hiOm3E5whJbPAAAAACWk6+RpenTp+vpp59Wv379XI6/++67mjFjhlq1alUQtV21DMN1zRIjSwAAAID15Gtk6dChQ87twi/UokUL7d+//4qLutoZNsdueKQkAAAAwKryFZZq1Kih//3vfzmOb9q0qcje+8iTzt9n6dxNaRlaAgAAACwnX9Pwhg4dqqFDh2r79u0KDw+XJG3btk3r1q3TlClTCrTAq5NjGh4bPAAAAABWla+RpRYtWmj+/PlKS0vTBx98oBUrVsgwDP3f//2f2rdvX9A1XnWM7GHJzGIAAAAA5CrfW4ffdtttuu2221yOpaWl6dChQ7rhhhuuuLCrmSMsObYOJy0BAAAA1pOvkaWL2bx5s9q0aVOQb3lVcq5ZsrF1OAAAAGBVBRqWkDfnp+E5HgMAAACwGsKSCQznx84GDwAAAIBVEZZMkH3NElkJAAAAsJ48b/Dw448/Xvac3bt3X1Ex14rs91liaAkAAACwnjyHpd69e+fpPJvNdvmTrnFsHQ4AAABYX57DUnx8fGHWcU3JMQ2PtAQAAABYDmuWTMBueAAAAID1EZZMYGSLSQZDSwAAAIDlEJZMkH0aHgAAAADrISyZIPtueEQmAAAAwHoISybIsRseaQkAAACwHMKSCew5NnggLQEAAABWQ1gywfk1S/asx2QlAAAAwHIISyY4vxseAAAAAKsiLJmCNUsAAACA1RGWTGDPtnU4WQkAAACwHsKSCXJsHc7QEgAAAGA5hCUT5Ng63MxiAAAAAOSKsGQC49zHbjt/AAAAAIDFEJZMcH4ant3lMQAAAADrICyZwOCmtAAAAIDlEZZMkHODB/NqAQAAAJA7wpIJ7Oc+drYOBwAAAKyLsGSC7CNLpCUAAADAeghLpji3ZuncoiU78/AAAAAAyyEsmcDu3OCB3fAAAAAAqyIsmSD7bnikJQAAAMB6CEsmcMy6c+6GR1oCAAAALIewZAK7Letjt7EbHgAAAGBZhCUTOEaWvLjPEgAAAGBZhCUTnF+zxMgSAAAAYFWEJROcv8+S4wBxCQAAALAawpIJ7HKsWWLrcAAAAMCqCEsmyD6yxMASAAAAYD2EJVOwZgkAAACwOsKSCezZbkprMLQEAAAAWA5hyQSO3fC8zq1ZAgAAAGA9hCUT5BxZMq8WAAAAALkjLJngfDhizRIAAABgVaaGpbS0NI0ZM0YNGzZUVFSUYmNjL/ua33//XREREfrhhx88UGHhMGxZH7uXMywRlwAAAACr8THz4lOmTNHOnTu1cOFCHT58WKNGjdL111+vtm3bXvQ148ePV0pKigerLHiOkSXnbnhkJQAAAMByTAtLKSkpWrp0qebPn6+wsDCFhYUpISFBixcvvmhY+uSTT/Tvv/96uNKCZ8+2dTgAAAAA6zFtGl58fLwyMjIUERHhPBYZGant27fLbs+5S9zx48c1depUvfDCC54ss1DYnbvhMbIEAAAAWJVpI0tJSUkqV66c/Pz8nMeCgoKUlpamEydOqHz58i7nv/zyy+rSpYtuuummK7quzXb5cwqbIxs5R5ZshiXqgnU5+oM+QV7RM3AXPYP8oG/gLqv0TF6vb1pYSk1NdQlKkpyP09PTXY5/++23iouL0+rVq6/4uoGBpa74Pa6Ut7e3y+PSpYsrKMj8umB9VuhfFC30DNxFzyA/6Bu4q6j0jGlhyd/fP0cocjwOCAhwHjtz5ozGjh2rcePGuRzPr6NHT5s+7S09M6sAx8jSiZMpSk4+bWZJsDibLeuHihX6F0UDPQN30TPID/oG7rJKzzjquBzTwlJwcLCOHz+ujIwM+fhklZGUlKSAgACVLl3aed6OHTt06NAhDRs2zOX1jz76qDp37uz2GibDMH+NkGFkW7NkN78mFA1W6F8ULfQM3EXPID/oG7irqPSMaWEpNDRUPj4+2rZtmxo2bChJiouLU926deXldX7fiXr16um///2vy2vbtGmjF198UXfccYdHay4o2dcscZ8lAAAAwHpMC0vFihVT586dNX78eE2ePFl///23YmNj9dJLL0nKGmUqVaqUAgICVLVq1RyvDw4OVmBgoKfLLhCGc+twx2MAAAAAVmPa1uGSFBMTo7CwMPXt21cTJkzQ0KFD1aZNG0lSVFSU1qxZY2Z5hca5dbgta4v0ojAECQAAAFxrTBtZkrJGl1555RW98sorOZ7bvXv3RV93qeeKAseaJedjk+oAAAAAcHGmjixdqxy33HXeZ4m0BAAAAFgOYckEjjVLXmzwAAAAAFgWYckE5zd4yApJdrISAAAAYDmEJRPYs4UlNngAAAAArIewZAJHODq/zQNpCQAAALAawpIJ7DbHyBJbhwMAAABWRVgygWPrcG5KCwAAAFgXYckE2Td4ICwBAAAA1kNYMoHjPktezvssEZcAAAAAqyEsmYCRJQAAAMD6CEsmsGdfs0RaAgAAACyHsGQCRpYAAAAA6yMsmcCxZun8TWmJSwAAAIDVEJZMkH1kCQAAAID1EJZMkGMaHpkJAAAAsBzCkgkyz23w4MWaJQAAAMCyCEumyL7BA3EJAAAAsBrCkgns2bIR0/AAAAAA6yEsmcBuc0zDs1/mTAAAAABmISyZwOCmtAAAAIDlEZZMYGfNEgAAAGB5hCUTOG5Cy9bhAAAAgHURlkyQee5j97KxdTgAAABgVYQlE5y/Ka3zAAAAAACLISyZwK5s0/BISwAAAIDlEJZMYBjnpuGxZgkAAACwLMKSCXLuhgcAAADAaghLJnCMJDnvs2RaJQAAAAAuhrBkguwjS8zDAwAAAKyHsGQC+7l/ejENDwAAALAswpIJnFuH29jgAQAAALAqwpIJDMN1tZKdsAQAAABYDmHJBJnn/unlnIBHWgIAAACshrBkAuc0PMdjshIAAABgOYQlE9gN7rMEAAAAWB1hyQSOkSV2wwMAAACsi7BkArvzprSO3fCISwAAAIDVEJZMkOOmtAAAAAAsh7BkguwRiYElAAAAwHoISyawn/vYvWSXxJolAAAAwIoISyZwrFGyZXsMAAAAwDoISyZgzRIAAABgfYQlE2QaWR/7+d3wzKwGAAAAQG4ISyZwZCNuSgsAAABYF2HJBDnCEkNLAAAAgOUQlkxgN2wuj4lKAAAAgPUQlkzg2ODB+9zW4QAAAACsh7BkghwjSwwtAQAAAJZjalhKS0vTmDFj1LBhQ0VFRSk2Nvai53755Zfq1KmTIiIi1LFjR33++ecerLRguY4nGTKYiAcAAABYjqlhacqUKdq5c6cWLlyocePGaebMmVq7dm2O8+Lj4zVkyBB17dpVK1euVI8ePfTEE08oPj7ehKqvnHHByJKXDEaWAAAAAAvyMevCKSkpWrp0qebPn6+wsDCFhYUpISFBixcvVtu2bV3OXb16tZo0aaI+ffpIkqpWraqNGzfqs88+U+3atc0o/4pcOLJkY1wJAAAAsCTTwlJ8fLwyMjIUERHhPBYZGak5c+bIbrfLy+v8oFeXLl109uzZHO9x+vRpj9Ra0C5cs2STwXZ4AAAAgAWZFpaSkpJUrlw5+fn5OY8FBQUpLS1NJ06cUPny5Z3Ha9So4fLahIQEfffdd+rRo4fb17XZLn9OYctUtml4MixRF6zL0R/0CfKKnoG76BnkB30Dd1mlZ/J6fdPCUmpqqktQkuR8nJ6eftHXHTt2TEOHDlWDBg101113uX3dwMBSbr+mwNlsztEkmwwVK+6voCAL1AXLs0T/okihZ+Auegb5Qd/AXUWlZ0wLS/7+/jlCkeNxQEBArq9JTk7WQw89JMMw9Oabb7pM1curo0dPm76hQma266f8m6bk5KI5pRCeYbNl/VCxQv+iaKBn4C56BvlB38BdVukZRx2XY1pYCg4O1vHjx5WRkSEfn6wykpKSFBAQoNKlS+c4/8iRI84NHhYtWuQyTc8dhmH+fY3shk2OmXg2GbLL/JpQNFihf1G00DNwFz2D/KBv4K6i0jOmbR0eGhoqHx8fbdu2zXksLi5OdevWzTFilJKSov79+8vLy0vvv/++goODPVxtwbpwNzwvFZFOAQAAAK4xpoWlYsWKqXPnzho/frx27NihDRs2KDY21jl6lJSUpDNnzkiS5s6dq4MHD+qVV15xPpeUlHTV7IZHVAIAAACsx7RpeJIUExOj8ePHq2/fvipZsqSGDh2qNm3aSJKioqL00ksvKTo6WuvWrdOZM2fUvXt3l9d36dJFL7/8shmlX5ELw5GNm9ICAAAAlmRqWCpWrJheeeUV54jRhXbv3u38eu3atZ4sq9DZjfMDel6MLAEAAACWZNo0vGuZ3SUeGTIYWgIAAAAsh7BkAtc1S+zvAAAAAFgRYckEmToflryyjTMBAAAAsAbCkgkMMbIEAAAAWB1hyQQXhqOsrcNJSwAAAIDVEJZM4Lp1OAAAAAArIiyZwDCkzHObPNhkZxoeAAAAYEGEJRMYOr9uySYxCQ8AAACwIMKSGQzjgrDEfZYAAAAAKyIsmcCQZD8XlrwYVwIAAAAsibBkgqyBpAtHlkwtBwAAAEAuCEsmMHR+nZKNjcMBAAAASyIsmcS5Zskm1iwBAAAAFkRY8jBHMLLrgq3DzSwIAAAAQK4ISx5mOP95futwAAAAANZDWPIwx4w7gw0eAAAAAEsjLHlY9pElLxls8QAAAABYEGHJ084NI7nshkdWAgAAACyHsORhOdcsMa4EAAAAWBFhycMco0j2C8ISaQkAAACwHsKSh+W2Gx5jSwAAAID1EJY8zHCuWWI3PAAAAMDKCEsmcdngwdRKAAAAAOSGsORhdud9lrI+ei/CEgAAAGBJhCUPc0SjC0eWmIcHAAAAWA9hycMM58jShRs8AAAAALAawpJJzm8dbmdgCQAAALAgwpKHMbIEAAAAFA2EJQ87v2bpwq3DiUsAAACA1RCWPCx7LuI+SwAAAIA1EZY8zJGL7EbWyBJbhwMAAADWRFjytBxrlhhZAgAAAKyIsORh2dcsOY4CAAAAsBbCkoc5p+HJMQ3PTlQCAAAALIiw5GG5bh1OWgIAAAAsh7DkYdlzkY0NHgAAAABLIix52rlhJPu5j97Lxn2WAAAAACsiLHmYke2fNsaVAAAAAEsiLHnY+UEkWy7HAAAAAFgFYcnDnCNLtgvus2ReOQAAAAAugrDkYY71SYZz63DWLAEAAABWRFgyyfmtwxlZAgAAAKyIsORh5zd4OB+WAAAAAFgPYcnDst+UNmsanokFAQAAAMgVYcnDHJPuDOdueAYT8QAAAAALIix52PmRpSw2sXU4AAAAYEWEJdOwwQMAAABgZYQlD3OMItnPffReMkRaAgAAAKzH1LCUlpamMWPGqGHDhoqKilJsbOxFz921a5e6d++u8PBwde3aVTt37vRgpQUney6ysWYJAAAAsCRTw9KUKVO0c+dOLVy4UOPGjdPMmTO1du3aHOelpKRowIABatiwoVasWKGIiAgNHDhQKSkpJlR9ZZw3pbVdMA2PrAQAAABYjmlhKSUlRUuXLtWzzz6rsLAwtW7dWv3799fixYtznLtmzRr5+/tr5MiRqlGjhp599lmVKFEi12BldY5cZGfNEgAAAGBppoWl+Ph4ZWRkKCIiwnksMjJS27dvl91udzl3+/btioyMlM0xGmOzqUGDBtq2bZsnSy4YzmRkc/4vYQkAAACwHh+zLpyUlKRy5crJz8/PeSwoKEhpaWk6ceKEypcv73JuzZo1XV4fGBiohIQEt69rs13+nEJ17vqO+yw97/ue/jmyQqdnm10YrO4045BwEz0Dd9EzyA/6BnmV6lVKtvavKyiokem/k+f1+qaFpdTUVJegJMn5OD09PU/nZj8vLwIDS7n9moJUonRxVSoToDTfG6R/flWI7aiko5L9si8FAAAAii67FPfXL5Iamf47eV6ZFpb8/f1zhB3H44CAgDydm/28vDh69LTpGyp89EhDBZd7Tyd3bdKfx//ViTNnzS0IlmeTVLx4gFJSzvDf7pAn9AzcRc8gP+gbuMO/ZHlVrdVIkvm/k9tseRtEMS0sBQcH6/jx48rIyJCPT1YZSUlJCggIUOnSpXOcm5yc7HIsOTlZFStWdPu6hiHTw5KPl5dsvgE6G3K7Aq+XAs0tB0WAzSYFBZVScrL5YR9FAz0Dd9EzyA/6Bm5zLEmxwO/keWHaBg+hoaHy8fFx2aQhLi5OdevWlZeXa1nh4eHaunXr+W23DUM//fSTwsPDPVkyAAAAgGuIaWGpWLFi6ty5s8aPH68dO3Zow4YNio2NVZ8+fSRljTKdOXNGktS2bVudOnVKkyZNUmJioiZNmqTU1FS1a9fOrPIBAAAAXOVMvSltTEyMwsLC1LdvX02YMEFDhw5VmzZtJElRUVFas2aNJKlkyZKaO3eu4uLiFB0dre3bt2vevHkqXry4meUDAAAAuIrZDKMozBYsOFaYU8v8XriLnoG76Bm4i55BftA3cJdVesZRx+WYOrIEAAAAAFZFWAIAAACAXBCWAAAAACAXhCUAAAAAyAVhCQAAAAByQVgCAAAAgFwQlgAAAAAgF4QlAAAAAMgFYQkAAAAAckFYAgAAAIBc+JhdgKfZbGZXcL4GK9SCooGegbvoGbiLnkF+0Ddwl1V6Jq/XtxmGYRRuKQAAAABQ9DANDwAAAAByQVgCAAAAgFwQlgAAAAAgF4QlAAAAAMgFYQkAAAAAckFYAgAAAIBcEJYAAAAAIBeEJQAAAADIBWEJAAAAAHJBWPKwtLQ0jRkzRg0bNlRUVJRiY2PNLgkWkZ6erg4dOuiHH35wHjt06JD69eun+vXrq3379vr6669dXvPtt9+qQ4cOCg8PV58+fXTo0CFPlw0THDlyRMOGDVOjRo3UtGlTvfTSS0pLS5NEzyB3Bw4c0COPPKKIiAg1b95cCxYscD5Hz+ByBgwYoNGjRzsf79q1S927d1d4eLi6du2qnTt3upy/evVqtWrVSuHh4Ro8eLCOHTvm6ZJhkvXr16tWrVouf4YNGyap6PYNYcnDpkyZop07d2rhwoUaN26cZs6cqbVr15pdFkyWlpam4cOHKyEhwXnMMAwNHjxYQUFBWr58uTp16qQhQ4bo8OHDkqTDhw9r8ODBio6O1rJly1S+fHkNGjRIhmGY9W3AAwzD0LBhw5SamqrFixfr9ddf1xdffKE33niDnkGu7Ha7BgwYoHLlyumjjz7ShAkTNHv2bK1atYqewWV9+umn2rRpk/NxSkqKBgwYoIYNG2rFihWKiIjQwIEDlZKSIknasWOHnn32WQ0ZMkRLlizRqVOnFBMTY1b58LDExES1aNFCX3/9tfPPiy++WLT7xoDH/Pvvv0bdunWN77//3nnsrbfeMh588EETq4LZEhISjHvvvdfo2LGjcfPNNzv749tvvzXq169v/Pvvv85z+/bta7z55puGYRjGG2+84dI7KSkpRkREhEt/4eqTmJho3HzzzUZSUpLz2KpVq4yoqCh6Brk6cuSI8cQTTxinT592Hhs8eLAxbtw4egaXdPz4cePOO+80unbtaowaNcowDMNYunSp0bJlS8NutxuGYRh2u91o3bq1sXz5csMwDOOZZ55xnmsYhnH48GGjVq1axsGDBz3/DcDjRowYYbz66qs5jhflvmFkyYPi4+OVkZGhiIgI57HIyEht375ddrvdxMpgps2bN6tx48ZasmSJy/Ht27frlltuUfHixZ3HIiMjtW3bNufzDRs2dD5XrFgxhYWFOZ/H1alChQpasGCBgoKCXI7/888/9AxyVbFiRb3xxhsqWbKkDMNQXFycfvzxRzVq1IiewSW98sor6tSpk2rWrOk8tn37dkVGRspms0mSbDabGjRocNGeqVSpkq6//npt377do7XDHHv37lW1atVyHC/KfUNY8qCkpCSVK1dOfn5+zmNBQUFKS0vTiRMnzCsMpurZs6fGjBmjYsWKuRxPSkpSxYoVXY4FBgbqr7/+ytPzuDqVLl1aTZs2dT622+16//331aRJE3oGl9WyZUv17NlTERERuvvuu+kZXNR3332nLVu2aNCgQS7HL9cTf//9Nz1zjTIMQ/v379fXX3+tu+++W61atdK0adOUnp5epPvGx+wCriWpqakuQUmS83F6eroZJcHCLtYvjl653PO4NkydOlW7du3SsmXL9O6779IzuKQ333xTycnJGj9+vF566SV+ziBXaWlpGjdu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&quot; 
     }, 
     &quot;metadata&quot;: {}, 
     &quot;output_type&quot;: &quot;display_data&quot; 
    } 
   ], 
   &quot;source&quot;: [ 
    &quot;# Plotting the training and validation loss\n&quot;, 
    &quot;plt.figure(figsize=(10, 5))\n&quot;, 
    &quot;plt.title(\&quot;Training and Validation Loss\&quot;)\n&quot;, 
    &quot;plt.plot(train_loss, label=\&quot;training\&quot;)\n&quot;, 
    &quot;plt.plot(val_loss, label=\&quot;validation\&quot;)\n&quot;, 
    &quot;plt.xlabel(\&quot;Epochs\&quot;)\n&quot;, 
    &quot;plt.ylabel(\&quot;Loss\&quot;)\n&quot;, 
    &quot;plt.legend()\n&quot;, 
    &quot;plt.show()\n&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;source&quot;: [ 
    &quot;# 7. evaluate on the test set&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: 49, 
   &quot;outputs&quot;: [ 
    { 
     &quot;name&quot;: &quot;stdout&quot;, 
     &quot;output_type&quot;: &quot;stream&quot;, 
     &quot;text&quot;: [ 
      &quot;Confusion Matrix:\n&quot;, 
      &quot;[[ 0 23]\n&quot;, 
      &quot; [ 0 47]]\n&quot;, 
      &quot;Accuracy: 0.6714285714285714\n&quot;, 
      &quot;Precision: 0.4508163265306122\n&quot;, 
      &quot;F1 Score: 0.5394383394383394\n&quot; 
     ] 
    }, 
    { 
     &quot;name&quot;: &quot;stderr&quot;, 
     &quot;output_type&quot;: &quot;stream&quot;, 
     &quot;text&quot;: [ 
      &quot;/Users/leonkiafaro/Library/Python/3.9/lib/python/site-packages/sklearn/metrics/_classification.py:1344: UndefinedMetricWarning: Precision is ill-defined and being set to 0.0 in labels with no predicted samples. Use `zero_division` parameter to control this behavior.\n&quot;, 
      &quot;  _warn_prf(average, modifier, msg_start, len(result))\n&quot; 
     ] 
    } 
   ], 
   &quot;source&quot;: [ 
    &quot;# Put model in evaluation mode\n&quot;, 
    &quot;net.eval()\n&quot;, 
    &quot;\n&quot;, 
    &quot;# Make predictions on the test data\n&quot;, 
    &quot;test_preds = net(X_test)\n&quot;, 
    &quot;\n&quot;, 
    &quot;# Convert the predictions from probabilities to classes\n&quot;, 
    &quot;_, preds_y = torch.max(test_preds, 1)\n&quot;, 
    &quot;\n&quot;, 
    &quot;# Calculate the confusion matrix\n&quot;, 
    &quot;cm = confusion_matrix(y_test, preds_y)\n&quot;, 
    &quot;\n&quot;, 
    &quot;# Calculate accuracy, precision and F1 score\n&quot;, 
    &quot;accuracy = accuracy_score(y_test, preds_y)\n&quot;, 
    &quot;precision = precision_score(y_test, preds_y, average='weighted')\n&quot;, 
    &quot;f1 = f1_score(y_test, preds_y, average='weighted')\n&quot;, 
    &quot;\n&quot;, 
    &quot;print(\&quot;Confusion Matrix:\&quot;)\n&quot;, 
    &quot;print(cm)\n&quot;, 
    &quot;\n&quot;, 
    &quot;print(f\&quot;Accuracy: {accuracy}\&quot;)\n&quot;, 
    &quot;print(f\&quot;Precision: {precision}\&quot;)\n&quot;, 
    &quot;print(f\&quot;F1 Score: {f1}\&quot;)\n&quot;, 
    &quot;\n&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;source&quot;: [], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  } 
 ], 
 &quot;metadata&quot;: { 
  &quot;kernelspec&quot;: { 
   &quot;display_name&quot;: &quot;Python 3&quot;, 
   &quot;language&quot;: &quot;python&quot;, 
   &quot;name&quot;: &quot;python3&quot; 
  }, 
  &quot;language_info&quot;: { 
   &quot;codemirror_mode&quot;: { 
    &quot;name&quot;: &quot;ipython&quot;, 
    &quot;version&quot;: 2 
   }, 
   &quot;file_extension&quot;: &quot;.py&quot;, 
   &quot;mimetype&quot;: &quot;text/x-python&quot;, 
   &quot;name&quot;: &quot;python&quot;, 
   &quot;nbconvert_exporter&quot;: &quot;python&quot;, 
   &quot;pygments_lexer&quot;: &quot;ipython2&quot;, 
   &quot;version&quot;: &quot;2.7.6&quot; 
  } 
 }, 
 &quot;nbformat&quot;: 4, 
 &quot;nbformat_minor&quot;: 0 
} 
</span></pre>
</body>
</html>